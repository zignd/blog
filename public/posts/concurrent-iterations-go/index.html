<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Concurrent iterations in Go :: Zignd&#39;s blog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="The Go programming language is very flexible when it comes to concurrency, the language syntax allows you create most of the concurrency flows that might come to your mind. But with this flexibility comes some complexity too. Below you will find some code I wrote when I was experimenting with the tools available in the default packages in order to build a few concurrent flows that came to my mind. The code is below is documented with comments placed where I found worth documenting."/>
<meta name="keywords" content="go, concurrency"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="http://blog.zignd.dev/posts/concurrent-iterations-go/" />


<link rel="stylesheet" href="http://blog.zignd.dev/assets/style.css">






<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://blog.zignd.dev/img/apple-touch-icon-144-precomposed.png">

<link rel="shortcut icon" href="http://blog.zignd.dev/img/favicon/orange.png">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Concurrent iterations in Go :: Zignd&#39;s blog — " />
<meta name="twitter:description" content="The Go programming language is very flexible when it comes to concurrency, the language syntax allows you create most of the concurrency flows that might come to your mind. But with this flexibility comes some complexity too. Below you will find some code I wrote when I was experimenting with the tools available in the default packages in order to build a few concurrent flows that came to my mind. The code is below is documented with comments placed where I found worth documenting." />
<meta name="twitter:site" content="http://blog.zignd.dev/" />
<meta name="twitter:creator" content="Zignd" />
<meta name="twitter:image" content="">


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Concurrent iterations in Go :: Zignd&#39;s blog — ">
<meta property="og:description" content="The Go programming language is very flexible when it comes to concurrency, the language syntax allows you create most of the concurrency flows that might come to your mind. But with this flexibility comes some complexity too. Below you will find some code I wrote when I was experimenting with the tools available in the default packages in order to build a few concurrent flows that came to my mind. The code is below is documented with comments placed where I found worth documenting." />
<meta property="og:url" content="http://blog.zignd.dev/posts/concurrent-iterations-go/" />
<meta property="og:site_name" content="Concurrent iterations in Go" />
<meta property="og:image" content="">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2017-02-27 00:00:00 &#43;0000 UTC" />











</head>
<body class="">


<div class="container headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Zignd&#39;s blog
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="http://blog.zignd.dev/posts/concurrent-iterations-go/">Concurrent iterations in Go</a></h1>
  <div class="post-meta">
      
    <span class="post-date">
      2017-02-27
    </span>
    
    
    <span class="post-author">::
      Zignd
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="http://blog.zignd.dev/tags/go/">go</a>&nbsp;
    
    #<a href="http://blog.zignd.dev/tags/concurrency/">concurrency</a>&nbsp;
    
  </span>
  

  

  <div class="post-content">
    <p>The Go programming language is very flexible when it comes to concurrency, the language syntax allows you create most of the concurrency flows that might come to your mind. But with this flexibility comes some complexity too. Below you will find some code I wrote when I was experimenting with the tools available in the default packages in order to build a few concurrent flows that came to my mind. The code is below is documented with comments placed where I found worth documenting. The following packages were used throughout the code:</p>
<ul>
<li><a href="https://golang.org/ref/spec#Channel_types">Channel types</a></li>
<li><a href="https://golang.org/pkg/sync/#WaitGroup">sync.WaitGroup</a></li>
<li><a href="https://golang.org/ref/spec#Select_statements">Select statements</a></li>
</ul>
<h2 id="controlled-concurrency">Controlled concurrency</h2>
<p>This type of iteration has a controlled number of concurrent tasks being executed.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;sync&#34;</span>
    <span style="color:#e6db74">&#34;time&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">controlledConcurrency</span>() {
    <span style="color:#75715e">// Note that the process should have more tasks to execute than the amount
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// it is allowed to execute concurrently. Because there is no point in doing
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// the opposite. tasks &gt; concurrency.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">tasks</span> = <span style="color:#ae81ff">100</span>

    <span style="color:#a6e22e">counter</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>

    <span style="color:#75715e">// To achieve that a buffered channel is needed, the channel length should
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// be the amount of tasks we want to concurrently execute.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">concurrency</span> = <span style="color:#ae81ff">30</span>
    <span style="color:#a6e22e">tokens</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{}, <span style="color:#a6e22e">concurrency</span>)
    <span style="color:#66d9ef">defer</span> close(<span style="color:#a6e22e">tokens</span>)
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">concurrency</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">tokens</span> <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">struct</span>{}{}
    }

    <span style="color:#75715e">// A sync.WaitGroup is used to allow the function to wait for the concurrent
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// tasks to finish before it return the control to the caller.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">tasks</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#75715e">// Increment the sync.WaitGroup before getting into the go routine.
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)

        <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) {
            <span style="color:#75715e">// Take a token from the tokens channel, doing so will indicate that
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// one of the concurrent tasks are being executed and will prevent
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// more than the allowed amount of tasks to execute concurrently.
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// It works because as soon as the channel runs out of tokens
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// further receive operations on it will lock until a token is sent
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// back to the channel.
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">token</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">tokens</span>
            <span style="color:#75715e">// Release the token and decrement the sync.WaitGroup counter at the
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// end of the task.
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">tokens</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">token</span> }()
            <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()

            <span style="color:#75715e">// Perform the task.
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">1000</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>)
            <span style="color:#a6e22e">counter</span> = <span style="color:#a6e22e">counter</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;finished task&#34;</span>, <span style="color:#a6e22e">i</span>)
        }(<span style="color:#a6e22e">i</span>)
    }

    <span style="color:#75715e">// Wait for the tasks to finish.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()

    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;finished %d tasks\n&#34;</span>, <span style="color:#a6e22e">counter</span>)
}
</code></pre></div><h2 id="controlled-concurrency-stopping-on-the-first-error">Controlled concurrency stopping on the first error</h2>
<p>This type of iteration has a controlled number of concurrent tasks being executed but it also has a mechanism that allows it to stop at the first error.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;sync&#34;</span>
    <span style="color:#e6db74">&#34;time&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">controlledConcurrencyStoppingOnFirstError</span>() {
    <span style="color:#75715e">// Note that the process should have more tasks to execute than the amount
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// it is allowed to execute concurrently. Because there is no point in doing
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// the opposite. tasks &gt; concurrency.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">tasks</span> = <span style="color:#ae81ff">100</span>

    <span style="color:#a6e22e">counter</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>

    <span style="color:#75715e">// To achieve that a buffered channel is needed, the channel length should
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// be the amount of tasks we want to concurrently execute.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">concurrency</span> = <span style="color:#ae81ff">30</span>
    <span style="color:#a6e22e">tokens</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{}, <span style="color:#a6e22e">concurrency</span>)
    <span style="color:#66d9ef">defer</span> close(<span style="color:#a6e22e">tokens</span>)
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">concurrency</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">tokens</span> <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">struct</span>{}{}
    }

    <span style="color:#75715e">// In this type of loop it is usually expected to be able to have access to
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// error value, to do so every iteration should return a result value, the
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// result in this case have a task field and an err field, and whenever
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// an error occurs during an iteration a result value should be return with
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// an error in the err field.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">results</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">tasks</span>)

    <span style="color:#75715e">// It is also necessary to have a channel that will be used to notify the
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// loop that it should stop.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">abort</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{})

    <span style="color:#75715e">// A sync.WaitGroup is used to allow the function to wait for the concurrent
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// tasks to finish before it return the control to the caller.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>

    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">task</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">task</span> &lt; <span style="color:#a6e22e">tasks</span>; <span style="color:#a6e22e">task</span><span style="color:#f92672">++</span> {
        <span style="color:#75715e">// Increment the sync.WaitGroup before getting into the go routine.
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)

        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">task</span>, <span style="color:#e6db74">&#34;...&#34;</span>)
        <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">task</span> <span style="color:#66d9ef">int</span>) {
            <span style="color:#75715e">// Decrement the sync.WaitGroup counter at the end of the task.
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
            <span style="color:#75715e">// Use a select statement to abort any pending operation ASAP
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">select</span> {
            <span style="color:#75715e">// Take a token from the tokens channel, doing so will indicate that
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// one of the concurrent tasks are being executed and will prevent
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// more than the allowed amount of tasks to execute concurrently.
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// It works because as soon as the channel runs out of tokens
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// further receive operations on it will lock until a token is sent
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// back to the channel.
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">token</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">tokens</span>:
                <span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">tokens</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">token</span> }()
                <span style="color:#a6e22e">results</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">doWork</span>(<span style="color:#a6e22e">counter</span>, <span style="color:#a6e22e">task</span>)
            <span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">abort</span>:
                <span style="color:#66d9ef">return</span>
            }
        }(<span style="color:#a6e22e">task</span>)
    }
    <span style="color:#75715e">// The closer go routine below is necessary to unlock the for loop that
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// receives from the results channel, not doing so will create a deadlock as
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// soon as the loop above finishes the tasks.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
        <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
        close(<span style="color:#a6e22e">results</span>)
    }()

    <span style="color:#75715e">// Consumes the results channel and abort the whole operation on the first
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// error.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">results</span> {
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">task</span>, <span style="color:#e6db74">&#34;Fail&#34;</span>)
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;sending abort sign: %v\n&#34;</span>, <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">err</span>)
            close(<span style="color:#a6e22e">abort</span>)
            <span style="color:#66d9ef">break</span>
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#a6e22e">counter</span> = <span style="color:#a6e22e">counter</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
            <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">task</span>, <span style="color:#e6db74">&#34;Ok&#34;</span>)
        }
    }

    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;finished %d tasks\n&#34;</span>, <span style="color:#a6e22e">counter</span>)
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">result</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">task</span> <span style="color:#66d9ef">int</span>
    <span style="color:#a6e22e">err</span>  <span style="color:#66d9ef">error</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doWork</span>(<span style="color:#a6e22e">counter</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">task</span> <span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">result</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">counter</span> &gt; <span style="color:#ae81ff">30</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">result</span>{
            <span style="color:#a6e22e">task</span>: <span style="color:#a6e22e">task</span>,
            <span style="color:#a6e22e">err</span>: <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;an error occurred at counter: %d, task: %d&#34;</span>,
                <span style="color:#a6e22e">counter</span>, <span style="color:#a6e22e">task</span>)}
    }

    <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">100</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>)
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">result</span>{<span style="color:#a6e22e">task</span>: <span style="color:#a6e22e">task</span>}
}
</code></pre></div>
  </div>
  

  

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2020 Powered by <a href="http://gohugo.io">Hugo</a></span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="http://blog.zignd.dev/assets/main.js"></script>
<script src="http://blog.zignd.dev/assets/prism.js"></script>





  
</div>

</body>
</html>
